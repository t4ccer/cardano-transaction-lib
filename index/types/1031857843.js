// This file was generated by purescript-docs-search
window.DocsSearchTypeIndex["1031857843"] = [{"values":[{"sourceSpan":{"start":[406,1],"name":".spago/parsing/v10.2.0/src/Parsing/String/Replace.purs","end":[410,36]},"score":1,"packageInfo":{"values":["parsing"],"tag":"Package"},"name":"splitCap","moduleName":"Parsing.String.Replace","info":{"values":[{"type":{"tag":"ForAll","contents":["a",{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Parsing"],"Parser"]},{"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"tag":"TypeVar","contents":"a"}]}]},{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Data","List","Types"],"NonEmptyList"]},{"tag":"ParensInType","contents":{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Data","Either"],"Either"]},{"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"tag":"TypeVar","contents":"a"}]}}]}]}]},null]}}],"tag":"ValueResult"},"hashAnchor":"v","comments":"#### Split on and capture all patterns\n\nFind all occurences of the pattern parser `sep`, split the\ninput `String`, capture all the matched patterns and the splits.\n\nThis function can be used instead of\n[Data.String.Common.split](https://pursuit.purescript.org/packages/purescript-strings/docs/Data.String.Common#v:split)\nor\n[Data.String.Regex.split](https://pursuit.purescript.org/packages/purescript-strings/docs/Data.String.Regex#v:split)\nor\n[Data.String.Regex.match](https://pursuit.purescript.org/packages/purescript-strings/docs/Data.String.Regex#v:match)\nor\n[Data.String.Regex.search](https://pursuit.purescript.org/packages/purescript-strings/docs/Data.String.Regex#v:search).\n\nThe input string will be split on every leftmost non-overlapping occurence\nof the pattern `sep`. The output list will contain\nthe parsed result of input string sections which match the `sep` pattern\nin `Right a`, and non-matching sections in `Left String`.\n\n#### Access the matched section of text\n\nTo capture the matched strings combine the pattern\nparser `sep` with the `match` combinator.\n\nWith the matched strings, we can reconstruct the input string.\nFor all `input`, `sep`, if\n\n```purescript\nlet output = splitCap input (match sep)\n```\n\nthen\n\n```purescript\ninput == fold (either identity fst <$> output)\n```\n\n#### Example\n\nSplit the input string on all `Int` pattern matches.\n\n```purescript\nsplitCap \"hay 1 straw 2 hay\" intDecimal\n```\n\nResult:\n\n```\n[Left \"hay \", Right 1, Left \" straw \", Right 2, Left \" hay\"]\n```\n\n#### Example\n\nFind the beginning positions of all pattern matches in the input.\n\n```purescript\ncatMaybes $ hush <$> splitCap \".ùù∫...\\n...ùù∫.\" (position <* string \"ùù∫\")\n```\n\nResult:\n\n```purescript\n[ Position {index: 1, line: 1, column: 2 }\n, Position { index: 9, line: 2, column: 4 }\n]\n```\n\n#### Example\n\nFind groups of balanced nested parentheses. This pattern is an example of\na ‚Äúcontext-free‚Äù grammar, a pattern that\n[can't be expressed by a regular expression](https://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags/1732454#1732454).\nWe can express the pattern with a recursive parser.\n\n```purescript\nbalancedParens :: Parser String Unit\nbalancedParens = do\n  void $ char '('\n  void $ manyTill (balancedParens <|> void anyCodePoint) (char ')')\n\nrmap fst <$> splitCap \"((üåº)) (()())\" (match balancedParens)\n```\n\nResult:\n\n```purescript\n[Right \"((üåº))\", Left \" \", Right \"(()())\"]\n```\n"}],"tag":"SearchResult"}]