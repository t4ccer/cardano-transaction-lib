// This file was generated by purescript-docs-search
window.DocsSearchTypeIndex["1321142605"] = [{"values":[{"sourceSpan":{"start":[257,1],"name":".spago/parsing/v10.2.0/src/Parsing/String.purs","end":[257,83]},"score":1,"packageInfo":{"values":["parsing"],"tag":"Package"},"name":"regex","moduleName":"Parsing.String","info":{"values":[{"type":{"tag":"ForAll","contents":["m",{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeConstructor","contents":[["Data","String","Regex","Flags"],"RegexFlags"]}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Data","Either"],"Either"]},{"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"tag":"ParensInType","contents":{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"tag":"TypeVar","contents":"m"}]},{"tag":"TypeConstructor","contents":[["Prim"],"String"]}]}}]}]}]},null]}}],"tag":"ValueResult"},"hashAnchor":"v","comments":"Compile a regular expression `String` into a regular expression parser.\n\nThis function will use the `Data.String.Regex.regex` function to compile\nand return a parser which can be used\nin a `ParserT String m` monad.\nIf compilation fails then this function will return `Left` a compilation\nerror message.\n\nThe returned parser will try to match the regular expression pattern once,\nstarting at the current parser position. On success, it will return\nthe matched substring.\n\nIf the RegExp `String` is constant then we can assume that compilation will\nalways succeed and `unsafeCrashWith` if it doesn’t. If we dynamically\ngenerate the RegExp `String` at runtime then we should handle the\ncase where compilation of the RegExp fails.\n\nThis function should be called outside the context of a `ParserT String m`\nmonad for two reasons:\n1. If we call this function inside of the `ParserT String m` monad and\n   then `fail` the parse when the compilation fails,\n   then that could be confusing because a parser failure is supposed to\n   indicate an invalid input string.\n   If the compilation failure occurs in an `alt` then the compilation\n   failure might not be reported at all and instead\n   the input string would be parsed incorrectly.\n2. Compiling a RegExp is expensive and it’s better to do it\n   once in advance and then use the compiled RegExp many times than\n   to compile the RegExp many times during the parse.\n\nThis parser may be useful for quickly consuming a large section of the\ninput `String`, because in a JavaScript runtime environment a compiled\nRegExp is a lot faster than a monadic parser built from parsing primitives.\n\n[*MDN Regular Expressions Cheatsheet*](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Cheatsheet)\n\n#### Example\n\nThis example shows how to compile and run the `xMany` parser which will\ncapture the regular expression pattern `x*`.\n\n```purescript\ncase regex \"x*\" noFlags of\n  Left compileError -> unsafeCrashWith $ \"xMany failed to compile: \" <> compileError\n  Right xMany -> runParser \"xxxZ\" do\n    xMany\n```\n\n#### Flags\n\nSet `RegexFlags` with the `Semigroup` instance like this.\n\n```purescript\nregex \"x*\" (dotAll <> ignoreCase)\n```\n\nThe `dotAll`, `unicode`, and `ignoreCase` flags might make sense for\na `regex` parser. The other flags will\nprobably cause surprising behavior and you should avoid them.\n\n[*MDN Advanced searching with flags*](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#advanced_searching_with_flags)\n"}],"tag":"SearchResult"}]