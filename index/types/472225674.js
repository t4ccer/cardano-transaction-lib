// This file was generated by purescript-docs-search
window.DocsSearchTypeIndex["472225674"] = [{"values":[{"sourceSpan":{"start":[528,1],"name":".spago/parsing/v10.2.0/src/Parsing.purs","end":[528,78]},"score":1,"packageInfo":{"values":["parsing"],"tag":"Package"},"name":"liftExceptT","moduleName":"Parsing","info":{"values":[{"type":{"tag":"ForAll","contents":["s",{"tag":"ForAll","contents":["m",{"tag":"ForAll","contents":["a",{"tag":"ConstrainedType","contents":[{"constraintClass":[["Control","Monad"],"Monad"],"constraintArgs":[{"tag":"TypeVar","contents":"m"}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Control","Monad","Except","Trans"],"ExceptT"]},{"tag":"TypeConstructor","contents":[["Prim"],"String"]}]},{"tag":"TypeVar","contents":"m"}]},{"tag":"TypeVar","contents":"a"}]}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"tag":"TypeVar","contents":"s"}]},{"tag":"TypeVar","contents":"m"}]},{"tag":"TypeVar","contents":"a"}]}]}]},null]},null]},null]}}],"tag":"ValueResult"},"hashAnchor":"v","comments":"Lift an `ExceptT String m a` computation into a `ParserT`.\n\nConsumes no parsing input, does not change the parser state at all.\nIf the `ExceptT` computation is `Left String`, then this will `fail` in the\n`ParserT` monad at the current input `Position`.\n\nThis is a “validation” function, for when we want to produce some\ndata from the parsing input or fail at the current\nparsing position if that’s impossible.\n"}],"tag":"SearchResult"},{"values":[{"sourceSpan":{"start":[484,1],"name":".spago/parsing/v10.2.0/src/Parsing/Combinators.purs","end":[484,56]},"score":1,"packageInfo":{"values":["parsing"],"tag":"Package"},"name":"advance","moduleName":"Parsing.Combinators","info":{"values":[{"type":{"tag":"ForAll","contents":["s",{"tag":"ForAll","contents":["m",{"tag":"ForAll","contents":["a",{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"tag":"TypeVar","contents":"s"}]},{"tag":"TypeVar","contents":"m"}]},{"tag":"TypeVar","contents":"a"}]}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"tag":"TypeVar","contents":"s"}]},{"tag":"TypeVar","contents":"m"}]},{"tag":"TypeVar","contents":"a"}]}]},null]},null]},null]}}],"tag":"ValueResult"},"hashAnchor":"v","comments":"If the parser succeeds without advancing the input stream position,\nthen force the parser to fail.\n\nThis combinator can be used to prevent infinite parser repetition.\n\nDoes not depend on or effect the `consumed` flag which indicates whether\nwe are committed to this parsing branch.\n"}],"tag":"SearchResult"},{"values":[{"sourceSpan":{"start":[367,1],"name":".spago/parsing/v10.2.0/src/Parsing/Combinators.purs","end":[367,61]},"score":1,"packageInfo":{"values":["parsing"],"tag":"Package"},"name":"skipMany1","moduleName":"Parsing.Combinators","info":{"values":[{"type":{"tag":"ForAll","contents":["s",{"tag":"ForAll","contents":["a",{"tag":"ForAll","contents":["m",{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"tag":"TypeVar","contents":"s"}]},{"tag":"TypeVar","contents":"m"}]},{"tag":"TypeVar","contents":"a"}]}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"tag":"TypeVar","contents":"s"}]},{"tag":"TypeVar","contents":"m"}]},{"tag":"TypeConstructor","contents":[["Data","Unit"],"Unit"]}]}]},null]},null]},null]}}],"tag":"ValueResult"},"hashAnchor":"v","comments":"Skip at least one instance of a phrase.\n"}],"tag":"SearchResult"},{"values":[{"sourceSpan":{"start":[363,1],"name":".spago/parsing/v10.2.0/src/Parsing/Combinators.purs","end":[363,60]},"score":1,"packageInfo":{"values":["parsing"],"tag":"Package"},"name":"skipMany","moduleName":"Parsing.Combinators","info":{"values":[{"type":{"tag":"ForAll","contents":["s",{"tag":"ForAll","contents":["a",{"tag":"ForAll","contents":["m",{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"tag":"TypeVar","contents":"s"}]},{"tag":"TypeVar","contents":"m"}]},{"tag":"TypeVar","contents":"a"}]}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"tag":"TypeVar","contents":"s"}]},{"tag":"TypeVar","contents":"m"}]},{"tag":"TypeConstructor","contents":[["Data","Unit"],"Unit"]}]}]},null]},null]},null]}}],"tag":"ValueResult"},"hashAnchor":"v","comments":"Skip many instances of a phrase.\n"}],"tag":"SearchResult"},{"values":[{"sourceSpan":{"start":[146,1],"name":".spago/parsing/v10.2.0/src/Parsing/Combinators.purs","end":[146,60]},"score":1,"packageInfo":{"values":["parsing"],"tag":"Package"},"name":"optional","moduleName":"Parsing.Combinators","info":{"values":[{"type":{"tag":"ForAll","contents":["m",{"tag":"ForAll","contents":["s",{"tag":"ForAll","contents":["a",{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"tag":"TypeVar","contents":"s"}]},{"tag":"TypeVar","contents":"m"}]},{"tag":"TypeVar","contents":"a"}]}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"tag":"TypeVar","contents":"s"}]},{"tag":"TypeVar","contents":"m"}]},{"tag":"TypeConstructor","contents":[["Data","Unit"],"Unit"]}]}]},null]},null]},null]}}],"tag":"ValueResult"},"hashAnchor":"v","comments":"Optionally parse something, failing quietly.\n\nTo optionally parse `p` and never fail: `optional (try p)`.\n"}],"tag":"SearchResult"},{"values":[{"sourceSpan":{"start":[375,1],"name":".spago/parsing/v10.2.0/src/Parsing/Combinators.purs","end":[375,65]},"score":1,"packageInfo":{"values":["parsing"],"tag":"Package"},"name":"notFollowedBy","moduleName":"Parsing.Combinators","info":{"values":[{"type":{"tag":"ForAll","contents":["s",{"tag":"ForAll","contents":["a",{"tag":"ForAll","contents":["m",{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"tag":"TypeVar","contents":"s"}]},{"tag":"TypeVar","contents":"m"}]},{"tag":"TypeVar","contents":"a"}]}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"tag":"TypeVar","contents":"s"}]},{"tag":"TypeVar","contents":"m"}]},{"tag":"TypeConstructor","contents":[["Data","Unit"],"Unit"]}]}]},null]},null]},null]}}],"tag":"ValueResult"},"hashAnchor":"v","comments":"Fail if the parser succeeds.\n\nWill never consume input.\n"}],"tag":"SearchResult"},{"values":[{"sourceSpan":{"start":[200,1],"name":".spago/parsing/v10.2.0/src/Parsing/Combinators.purs","end":[200,58]},"score":1,"packageInfo":{"values":["parsing"],"tag":"Package"},"name":"lookAhead","moduleName":"Parsing.Combinators","info":{"values":[{"type":{"tag":"ForAll","contents":["s",{"tag":"ForAll","contents":["a",{"tag":"ForAll","contents":["m",{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"tag":"TypeVar","contents":"s"}]},{"tag":"TypeVar","contents":"m"}]},{"tag":"TypeVar","contents":"a"}]}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"tag":"TypeVar","contents":"s"}]},{"tag":"TypeVar","contents":"m"}]},{"tag":"TypeVar","contents":"a"}]}]},null]},null]},null]}}],"tag":"ValueResult"},"hashAnchor":"v","comments":"Parse a phrase, without modifying the consumed state or stream position.\n"}],"tag":"SearchResult"},{"values":[{"sourceSpan":{"start":[189,1],"name":".spago/parsing/v10.2.0/src/Parsing/Combinators.purs","end":[189,59]},"score":1,"packageInfo":{"values":["parsing"],"tag":"Package"},"name":"tryRethrow","moduleName":"Parsing.Combinators","info":{"values":[{"type":{"tag":"ForAll","contents":["m",{"tag":"ForAll","contents":["s",{"tag":"ForAll","contents":["a",{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"tag":"TypeVar","contents":"s"}]},{"tag":"TypeVar","contents":"m"}]},{"tag":"TypeVar","contents":"a"}]}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"tag":"TypeVar","contents":"s"}]},{"tag":"TypeVar","contents":"m"}]},{"tag":"TypeVar","contents":"a"}]}]},null]},null]},null]}}],"tag":"ValueResult"},"hashAnchor":"v","comments":"If the parser fails then backtrack the input stream to the unconsumed state.\n\nLike `try`, but will reposition the error to the `try` point.\n\n```\n>>> runParser \"ac\" (try (char 'a' *> char 'b'))\nLeft (ParseError \"Expected 'b'\" (Position { index: 1, line: 1, column: 2 }))\n```\n---\n```\n>>> runParser \"ac\" (tryRethrow (char 'a' *> char 'b'))\nLeft (ParseError \"Expected 'b'\" (Position { index: 0, line: 1, column: 1 }))\n```\n"}],"tag":"SearchResult"},{"values":[{"sourceSpan":{"start":[166,1],"name":".spago/parsing/v10.2.0/src/Parsing/Combinators.purs","end":[166,52]},"score":1,"packageInfo":{"values":["parsing"],"tag":"Package"},"name":"try","moduleName":"Parsing.Combinators","info":{"values":[{"type":{"tag":"ForAll","contents":["m",{"tag":"ForAll","contents":["s",{"tag":"ForAll","contents":["a",{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"tag":"TypeVar","contents":"s"}]},{"tag":"TypeVar","contents":"m"}]},{"tag":"TypeVar","contents":"a"}]}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Parsing"],"ParserT"]},{"tag":"TypeVar","contents":"s"}]},{"tag":"TypeVar","contents":"m"}]},{"tag":"TypeVar","contents":"a"}]}]},null]},null]},null]}}],"tag":"ValueResult"},"hashAnchor":"v","comments":"If the parser fails then backtrack the input stream to the unconsumed state.\n\nOne use for this combinator is to ensure that the right parser of an\nalternative will always be tried when the left parser fails.\n```\n>>> runParser \"ac\" ((char 'a' *> char 'b') <|> (char 'a' *> char 'c'))\nLeft (ParseError \"Expected 'b'\" (Position { line: 1, column: 2 }))\n```\n---\n```\n>>> runParser \"ac\" (try (char 'a' *> char 'b') <|> (char 'a' *> char 'c'))\nRight 'c'\n```\n"}],"tag":"SearchResult"},{"values":[{"sourceSpan":{"start":[40,1],"name":".spago/profunctor-lenses/v8.0.0/src/Data/Lens/Common.purs","end":[40,53]},"score":1,"packageInfo":{"values":["profunctor-lenses"],"tag":"Package"},"name":"simple","moduleName":"Data.Lens.Common","info":{"values":[{"type":{"tag":"ForAll","contents":["p",{"tag":"ForAll","contents":["s",{"tag":"ForAll","contents":["a",{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Data","Lens","Types"],"Optic'"]},{"tag":"TypeVar","contents":"p"}]},{"tag":"TypeVar","contents":"s"}]},{"tag":"TypeVar","contents":"a"}]}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Data","Lens","Types"],"Optic'"]},{"tag":"TypeVar","contents":"p"}]},{"tag":"TypeVar","contents":"s"}]},{"tag":"TypeVar","contents":"a"}]}]},null]},null]},null]}}],"tag":"ValueResult"},"hashAnchor":"v","comments":"This is useful for when you want to restrict the type of another optic.\nFor example, suppose you have the following declarations:\n```purescript\nnewtype X = X Int\nderive instance newtypeX :: Newtype X _\n```\n\nAttempting to view with the `_Newtype` optic:\n```purescript\nX 42 ^. _Newtype\n```\nWill result in a type error:\n```\n The inferred type\n   forall t3 t5. Newtype t3 t5 => Int\n has type variables which are not mentioned in the body of the type.\n Consider adding a type annotation.\n```\n\nHowever, if we apply the `simple` function:\n```purescript\n X 42 ^. simple _Newtype\n```\nWe get the expected result `42`.\n"}],"tag":"SearchResult"}]